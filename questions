Questions

1. Consider the thread created in start_listener. How many threads with this functionality should be running on the server at any given time?


Only one thread with a listener functionality is needed at a time. It is uneccessary to have
multiple threads listening to and being ready to accept client requests.


2. In the listener function, what do each of the following fields of the sockaddr_in struct represent: sin_family, sin_port, and sin_addr.s_addr?


sin_family: Family of addresses (typically set AF_INET) used to specify what kind of addresses our kernal/server supports.
sin_port: The port number used in the client/server connection. It is necessary to convert this number to network byte order using the function htons().
sin_addr.s_addr: Containst the host IP address (in the case of a server, it's the IP of the machine running the server).


3. What is the purpose of each of the following function calls in listener: socket, bind, listen, and accept? You should explain what each call does and what the effect would be if it were not called.


socket: Creates a socket with the specified addresses (AF_INET) and of the right type (SOCKSTREAM). Without this call there would be no socket for client communication and nothing would work.
bind: Binds an address to a socket. Without this call, clients would not be able to communicate with the server as the although a socket was created, it would not be bound to anything.
listen: listens for connections on a socket. Marks the specified socket (desginated by the first argument) as passive, meaning that it ready to accept incoming connection requests. Without this call, our socket would not be able to accept any incoming connection requests.
accept: Accept a connection on a socket. Without this call, clients that connected to the server would never leave the queue of pending connections.


4. Which protocol (TCP or UDP) is used for communication? Why is this protocol used? (Hint: see line 35 in comm.c)


TCP is used for communication (UDP uses SOCK_DGRAM). TCP allows for back and forth communication between two parties until one terminates the connection. UDP would only allow for one communication and reply before it terminated. UDP would not work for this project as we need back and forth communication.


5. Describe what comm_serve does. How are the response and command parameters used? What would happen if the stream pointed to by cxstr were closed?


Comm_serve parses input from the client. As long as cxstr remains open (socket stream), comm_serv will fill the buffers created in server.c (resp and cmd passed into the call to comm_serv) and then use the interpret_command function to execute the command and provide a response to the server.
If the stream pointed to by cxstr were closed, comm_serv would interpret the termination message and print out an appropriate message.


6. Describe, in detail, what happens during each iteration of the while loop in the listener function. Be sure to include explanations of all significant function calls.


During each iteration of the while loop in the listener function, the function first attempts to accept a client connection on a socket with the following call: accept(lsock, (struct sockaddr *)&client_addr, &client_len). If successful, inet_ntoa is used to print a readable version of the connection to the viewer. Finally, a new file pointer, cxstr, is created and set equal to fdopen(csock, "w+"). csock is the saved return value of a successful call to accept (the file descriptor for the accepted socket). This opened file is finally used as the parameter to the server function. If at any point accept or fdopen fails, the program handles it accordingly, prints out an error message, and continues the while loop.


